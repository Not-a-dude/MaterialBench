#version 450

#define TILE_DIM 16
layout(local_size_x = TILE_DIM, local_size_y = TILE_DIM, local_size_z = 1) in;

layout(binding = 0) readonly buffer MatrixA {
    float elements[];
} matrixA;

layout(binding = 1) readonly buffer MatrixB {
    float elements[];
} matrixB;

layout(binding = 2) writeonly buffer MatrixC {
    float elements[];
} matrixC;

layout(push_constant) uniform PushConstants {
    uint N;
    uint M;
    uint K;
} pc;

shared float tileA[TILE_DIM][TILE_DIM];
shared float tileB[TILE_DIM][TILE_DIM];

void main() {
    uint globalRow = gl_GlobalInvocationID.y;
    uint globalCol = gl_GlobalInvocationID.x;
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;

    float sum = 0.0;
    uint numTiles = (pc.K + TILE_DIM - 1) / TILE_DIM;

    for (uint tile = 0; tile < numTiles; ++tile) {
        // Load tiles with bounds checking
        uint aRow = globalRow;
        uint aCol = tile * TILE_DIM + localCol;
        uint bRow = tile * TILE_DIM + localRow;
        uint bCol = globalCol;

        tileA[localRow][localCol] = (aRow < pc.N && aCol < pc.K)
        ? matrixA.elements[aRow * pc.K + aCol] : 0.0;

        tileB[localRow][localCol] = (bRow < pc.K && bCol < pc.M)
        ? matrixB.elements[bRow * pc.M + bCol] : 0.0;

        barrier();

        // Compute partial sum
        for (uint k = 0; k < TILE_DIM; ++k) {
            sum += tileA[localRow][k] * tileB[k][localCol];
        }

        barrier();
    }

    // Write result with bounds checking
    if (globalRow < pc.N && globalCol < pc.M) {
        matrixC.elements[globalRow * pc.M + globalCol] = sum;
    }
}